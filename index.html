<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Geometry Dash - Numero Uno</title>
<style>
  body {
    margin: 0; 
    background: linear-gradient(135deg, #4e54c8, #8f94fb);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
  }
  h1 {
    color: white;
    margin: 20px 0 10px 0;
    text-shadow: 1px 1px 4px #0008;
  }
  #game-container {
    position: relative;
    width: 600px;
    height: 300px;
    background: #222;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 30px #0009 inset;
  }
  #play-button {
    margin-top: 15px;
    padding: 10px 20px;
    font-size: 1.2rem;
    background: #4e54c8;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #play-button:hover {
    background: #3b3fc1;
  }
  canvas {
    display: block;
    background: linear-gradient(to bottom, #6dd5fa, #2980b9);
    border-radius: 12px;
  }
  #progress {
    color: white;
    font-family: Consolas, monospace;
    font-size: 18px;
    margin: 8px 0 0 0;
    text-shadow: 1px 1px 3px #0009;
    user-select: none;
  }
</style>
</head>
<body>

<h1>Geometry Dash - Numero Uno</h1>
<div id="game-container">
  <canvas id="game" width="600" height="300"></canvas>
</div>
<div id="progress">Progress: 0%</div>
<button id="play-button">Play</button>

<audio id="bg-music" loop>
  <source src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_4d9f4d61ec.mp3?filename=game-music-loop-6294.mp3" type="audio/mpeg">
</audio>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  const progressDisplay = document.getElementById('progress');
  const bgMusic = document.getElementById('bg-music');

  let gameRunning = false;
  let gameOver = false;
  let gameWin = false;
  let startTime = 0;
  const levelDuration = 30000; // 30 seconds

  const player = {
    x: 80,
    y: height - 50,
    width: 30,
    height: 30,
    color: '#ffd700',
    vy: 0,
    gravity: 0.8,
    jumpPower: -14,
    onGround: true,
    baseY: height - 50,
  };

  const spikeWidth = 25;
  const spikeHeight = 25;
  const spikeSpeed = 6;
  let spikes = [];

  function generateSpikes() {
    spikes = [];
    let xPos = 600;
    while (xPos < 10800) {
      const makePair = Math.random() < 0.3;

      if (makePair) {
        spikes.push({
          x: xPos,
          y: height - spikeHeight,
          width: spikeWidth,
          height: spikeHeight,
        });
        spikes.push({
          x: xPos + spikeWidth + 2,
          y: height - spikeHeight,
          width: spikeWidth,
          height: spikeHeight,
        });
        xPos += (spikeWidth * 2) + 2 + 250 + Math.random() * 250;
      } else {
        spikes.push({
          x: xPos,
          y: height - spikeHeight,
          width: spikeWidth,
          height: spikeHeight,
        });
        xPos += 250 + Math.random() * 250;
      }
    }
  }

  function resetGame() {
    gameOver = false;
    gameWin = false;
    startTime = performance.now();
    player.y = player.baseY;
    player.vy = 0;
    player.onGround = true;
    spikes = [];
    generateSpikes();
    progressDisplay.textContent = 'Progress: 0%';

    bgMusic.pause();
    bgMusic.currentTime = 0;
    bgMusic.play().catch(() => {});
  }

  function drawSpike(x, y, w, h) {
    ctx.fillStyle = '#ff3b3b';
    ctx.beginPath();
    ctx.moveTo(x, y + h);        // bottom left
    ctx.lineTo(x + w / 2, y);    // top center (spike tip)
    ctx.lineTo(x + w, y + h);    // bottom right
    ctx.closePath();
    ctx.fill();
  }

  // Helper: check if point P(px,py) is inside triangle ABC
  // Using barycentric technique
  function pointInTriangle(px, py, ax, ay, bx, by, cx, cy) {
    const v0x = cx - ax;
    const v0y = cy - ay;
    const v1x = bx - ax;
    const v1y = by - ay;
    const v2x = px - ax;
    const v2y = py - ay;

    const dot00 = v0x * v0x + v0y * v0y;
    const dot01 = v0x * v1x + v0y * v1y;
    const dot02 = v0x * v2x + v0y * v2y;
    const dot11 = v1x * v1x + v1y * v1y;
    const dot12 = v1x * v2x + v1y * v2y;

    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) return false;

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    return (u >= 0) && (v >= 0) && (u + v < 1);
  }

  // More accurate collision: check if any of the player's corners is inside spike triangle
  function checkSpikeCollision(spike) {
    // Spike triangle points
    const ax = spike.x;
    const ay = spike.y + spike.height;
    const bx = spike.x + spike.width / 2;
    const by = spike.y;
    const cx = spike.x + spike.width;
    const cy = spike.y + spike.height;

    // Player corners
    const corners = [
      { x: player.x, y: player.y }, // top-left
      { x: player.x + player.width, y: player.y }, // top-right
      { x: player.x, y: player.y + player.height }, // bottom-left
      { x: player.x + player.width, y: player.y + player.height } // bottom-right
    ];

    // Check if any corner inside spike
    for (const corner of corners) {
      if (pointInTriangle(corner.x, corner.y, ax, ay, bx, by, cx, cy)) {
        return true;
      }
    }

    // Optional: check if spike tip inside player rectangle (for very precise)
    // Spike tip = (bx, by)
    if (bx >= player.x && bx <= player.x + player.width &&
        by >= player.y && by <= player.y + player.height) {
      return true;
    }

    return false;
  }

  function gameLoop(timestamp) {
    if (!gameRunning) return;

    ctx.clearRect(0, 0, width, height);

    // Background
    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
    bgGradient.addColorStop(0, '#6dd5fa');
    bgGradient.addColorStop(1, '#2980b9');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, width, height);

    // Ground
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, height - 40, width, 40);

    // Player physics
    player.vy += player.gravity;
    player.y += player.vy;

    if (player.y > player.baseY) {
      player.y = player.baseY;
      player.vy = 0;
      player.onGround = true;
    }

    // Draw player
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Move and draw spikes + check collision
    for (const spike of spikes) {
      spike.x -= spikeSpeed;
      drawSpike(spike.x, spike.y, spike.width, spike.height);

      if (checkSpikeCollision(spike)) {
        gameOver = true;
      }
    }

    // Progress
    const elapsed = timestamp - startTime;
    const progressPercent = Math.min(100, (elapsed / levelDuration) * 100);
    progressDisplay.textContent = `Progress: ${progressPercent.toFixed(1)}%`;

    if (gameOver) {
      bgMusic.pause();

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'white';
      ctx.font = '36px Arial Black, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', width / 2, height / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Click Play to try again', width / 2, height / 2 + 20);

      gameRunning = false;
      document.getElementById('play-button').style.display = 'inline-block';
      return;
    }

    if (elapsed >= levelDuration) {
      bgMusic.pause();

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'white';
      ctx.font = '36px Arial Black, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Level Complete!', width / 2, height / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Click Play to play again', width / 2, height / 2 + 20);

      gameRunning = false;
      document.getElementById('play-button').style.display = 'inline-block';
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  function jump() {
    if (!gameRunning) return;
    if (player.onGround) {
      player.vy = player.jumpPower;
      player.onGround = false;
    }
  }

  canvas.addEventListener('mousedown', (e) => {
    jump();
  });
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    jump();
  }, {passive: false});

  const playBtn = document.getElementById('play-button');
  playBtn.addEventListener('click', () => {
    resetGame();
    gameRunning = true;
    playBtn.style.display = 'none';
    progressDisplay.textContent = 'Progress: 0%';
    requestAnimationFrame(gameLoop);
  });
})();
</script>

</body>
</html>
